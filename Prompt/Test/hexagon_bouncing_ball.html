<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…­è¾¹å½¢è¾¹ç•Œå†…å¼¹è·³å°çƒæ¨¡æ‹Ÿå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0f1e 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
        }

        #canvasContainer {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #simulationCanvas {
            border: 1px solid rgba(100, 149, 237, 0.3);
            box-shadow: 0 0 50px rgba(100, 149, 237, 0.2);
        }

        /* æ§åˆ¶é¢æ¿æ ·å¼ */
        #controlPanel {
            width: 320px;
            background: rgba(30, 30, 50, 0.9);
            backdrop-filter: blur(10px);
            padding: 25px;
            box-shadow: -5px 0 20px rgba(0, 0, 0, 0.3);
            border-left: 2px solid rgba(100, 149, 237, 0.5);
            overflow-y: auto;
        }

        #controlPanel h2 {
            margin-bottom: 25px;
            color: #6495ed;
            font-size: 24px;
            text-align: center;
            text-shadow: 0 0 10px rgba(100, 149, 237, 0.5);
            border-bottom: 2px solid rgba(100, 149, 237, 0.3);
            padding-bottom: 15px;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #a8b2d1;
            font-size: 14px;
            font-weight: 500;
        }

        .control-group .value-display {
            color: #6495ed;
            font-weight: bold;
            float: right;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(100, 149, 237, 0.2);
            outline: none;
            -webkit-appearance: none;
            transition: background 0.3s;
        }

        .slider:hover {
            background: rgba(100, 149, 237, 0.3);
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6495ed, #4169e1);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 149, 237, 0.5);
            transition: all 0.3s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(100, 149, 237, 0.8);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6495ed, #4169e1);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 149, 237, 0.5);
            border: none;
            transition: all 0.3s ease;
        }

        .slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(100, 149, 237, 0.8);
        }

        .info-panel {
            margin-top: 30px;
            padding: 20px;
            background: rgba(100, 149, 237, 0.1);
            border-radius: 10px;
            border: 1px solid rgba(100, 149, 237, 0.3);
        }

        .info-panel h3 {
            color: #6495ed;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 13px;
            color: #a8b2d1;
        }

        .info-value {
            color: #fff;
            font-weight: bold;
        }

        .preset-buttons {
            margin-top: 25px;
        }

        .preset-btn {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            background: rgba(100, 149, 237, 0.2);
            color: #a8b2d1;
            border: 1px solid rgba(100, 149, 237, 0.4);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .preset-btn:hover {
            background: rgba(100, 149, 237, 0.3);
            color: #fff;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(100, 149, 237, 0.3);
        }

        .preset-btn:active {
            transform: translateY(0);
        }

        /* æ ‡é¢˜æ ·å¼ */
        .title {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #6495ed;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(100, 149, 237, 0.5);
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            #controlPanel {
                width: 100%;
                height: 200px;
                border-left: none;
                border-top: 2px solid rgba(100, 149, 237, 0.5);
            }

            .title {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="title">å…­è¾¹å½¢è¾¹ç•Œå†…å¼¹è·³å°çƒæ¨¡æ‹Ÿå™¨</div>

    <div id="canvasContainer">
        <canvas id="simulationCanvas"></canvas>
    </div>

    <div id="controlPanel">
        <h2>ğŸ® æ¨¡æ‹Ÿå‚æ•°</h2>

        <div class="control-group">
            <label>
                å°çƒå¤§å° (Ball Size)
                <span class="value-display" id="ballSizeValue">15px</span>
            </label>
            <input type="range" id="ballSize" class="slider" min="5" max="30" value="15" step="1">
        </div>

        <div class="control-group">
            <label>
                é‡åŠ› (Gravity)
                <span class="value-display" id="gravityValue">0.5</span>
            </label>
            <input type="range" id="gravity" class="slider" min="0" max="1" value="0.5" step="0.01">
        </div>

        <div class="control-group">
            <label>
                å¼¹æ€§ (Elasticity)
                <span class="value-display" id="elasticityValue">0.9</span>
            </label>
            <input type="range" id="elasticity" class="slider" min="0" max="1" value="0.9" step="0.01">
        </div>

        <div class="control-group">
            <label>
                æ—‹è½¬é€Ÿåº¦ (Rotation Speed)
                <span class="value-display" id="rotationSpeedValue">1Â°/å¸§</span>
            </label>
            <input type="range" id="rotationSpeed" class="slider" min="0" max="5" value="1" step="0.1">
        </div>

        <div class="preset-buttons">
            <button class="preset-btn" onclick="setPreset('lowGravity')">ğŸŒ™ ä½é‡åŠ›æ¨¡å¼</button>
            <button class="preset-btn" onclick="setPreset('highBounce')">ğŸ€ é«˜å¼¹æ€§æ¨¡å¼</button>
            <button class="preset-btn" onclick="setPreset('fastRotation')">ğŸŒªï¸ å¿«é€Ÿæ—‹è½¬æ¨¡å¼</button>
            <button class="preset-btn" onclick="setPreset('chaos')">ğŸ² æ··æ²Œæ¨¡å¼</button>
            <button class="preset-btn" onclick="resetSimulation()">ğŸ”„ é‡ç½®æ¨¡æ‹Ÿ</button>
        </div>

        <div class="info-panel">
            <h3>ğŸ“Š å®æ—¶ä¿¡æ¯</h3>
            <div class="info-item">
                <span>ç¢°æ’æ¬¡æ•°ï¼š</span>
                <span class="info-value" id="collisionCount">0</span>
            </div>
            <div class="info-item">
                <span>å½“å‰é€Ÿåº¦ï¼š</span>
                <span class="info-value" id="currentSpeed">0</span>
            </div>
            <div class="info-item">
                <span>è½¨è¿¹ç‚¹æ•°ï¼š</span>
                <span class="info-value" id="trailCount">0</span>
            </div>
            <div class="info-item">
                <span>å¸§ç‡ (FPS)ï¼š</span>
                <span class="info-value" id="fps">60</span>
            </div>
        </div>
    </div>

    <script>
        // è·å–ç”»å¸ƒå’Œä¸Šä¸‹æ–‡
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');

        // è®¾ç½®ç”»å¸ƒå¤§å°
        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            canvas.width = container.clientWidth - 100;
            canvas.height = container.clientHeight - 100;
        }

        // æ¨¡æ‹Ÿå‚æ•°
        let params = {
            ballSize: 15,
            gravity: 0.5,
            elasticity: 0.9,
            rotationSpeed: 1 // åº¦/å¸§
        };

        // ç»Ÿè®¡ä¿¡æ¯
        let stats = {
            collisionCount: 0,
            currentSpeed: 0,
            trailCount: 0,
            fps: 60
        };

        // å…­è¾¹å½¢ç±»
        class Hexagon {
            constructor(centerX, centerY, radius) {
                this.centerX = centerX;
                this.centerY = centerY;
                this.radius = radius;
                this.rotation = 0;
                this.vertices = [];
                this.updateVertices();
            }

            updateVertices() {
                this.vertices = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i + this.rotation;
                    const x = this.centerX + this.radius * Math.cos(angle);
                    const y = this.centerY + this.radius * Math.sin(angle);
                    this.vertices.push({ x, y });
                }
            }

            rotate(angle) {
                this.rotation += angle;
                this.updateVertices();
            }

            draw() {
                // ç»˜åˆ¶å‘å…‰æ•ˆæœ
                ctx.shadowColor = '#6495ed';
                ctx.shadowBlur = 20;

                // ç»˜åˆ¶å…­è¾¹å½¢è¾¹æ¡†
                ctx.strokeStyle = '#6495ed';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(this.vertices[0].x, this.vertices[0].y);

                for (let i = 1; i < this.vertices.length; i++) {
                    ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
                }

                ctx.closePath();
                ctx.stroke();

                // ç»˜åˆ¶å†…éƒ¨å¡«å……
                ctx.fillStyle = 'rgba(100, 149, 237, 0.1)';
                ctx.fill();

                // é‡ç½®é˜´å½±
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }

            // æ£€æµ‹ç‚¹æ˜¯å¦åœ¨å…­è¾¹å½¢å†…
            containsPoint(x, y) {
                // ä½¿ç”¨å‰ç§¯åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨å…­è¾¹å½¢å†…
                let inside = true;
                for (let i = 0; i < 6; i++) {
                    const v1 = this.vertices[i];
                    const v2 = this.vertices[(i + 1) % 6];

                    const cross = (v2.x - v1.x) * (y - v1.y) - (v2.y - v1.y) * (x - v1.x);
                    if (cross < 0) {
                        inside = false;
                        break;
                    }
                }
                return inside;
            }

            // è·å–æœ€è¿‘çš„è¾¹å’Œæ³•å‘é‡
            getClosestEdge(x, y) {
                let minDistance = Infinity;
                let closestEdge = null;
                let normal = null;

                for (let i = 0; i < 6; i++) {
                    const v1 = this.vertices[i];
                    const v2 = this.vertices[(i + 1) % 6];

                    // è®¡ç®—ç‚¹åˆ°çº¿æ®µçš„è·ç¦»
                    const edgeX = v2.x - v1.x;
                    const edgeY = v2.y - v1.y;
                    const edgeLength = Math.sqrt(edgeX * edgeX + edgeY * edgeY);

                    const t = Math.max(0, Math.min(1, ((x - v1.x) * edgeX + (y - v1.y) * edgeY) / (edgeLength * edgeLength)));

                    const closestX = v1.x + t * edgeX;
                    const closestY = v1.y + t * edgeY;

                    const distance = Math.sqrt((x - closestX) * (x - closestX) + (y - closestY) * (y - closestY));

                    if (distance < minDistance) {
                        minDistance = distance;
                        closestEdge = { v1, v2, closestX, closestY };

                        // è®¡ç®—æ³•å‘é‡ï¼ˆæŒ‡å‘å…­è¾¹å½¢å†…éƒ¨ï¼‰
                        const edgeNormalX = -edgeY / edgeLength;
                        const edgeNormalY = edgeX / edgeLength;

                        // ç¡®ä¿æ³•å‘é‡æŒ‡å‘å†…éƒ¨
                        const centerDirX = this.centerX - closestX;
                        const centerDirY = this.centerY - closestY;

                        if (edgeNormalX * centerDirX + edgeNormalY * centerDirY < 0) {
                            normal = { x: -edgeNormalX, y: -edgeNormalY };
                        } else {
                            normal = { x: edgeNormalX, y: edgeNormalY };
                        }
                    }
                }

                return { edge: closestEdge, normal, distance: minDistance };
            }
        }

        // å°çƒç±»
        class Ball {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = (Math.random() - 0.5) * 10;
                this.color = this.getRandomColor();
                this.trail = [];
                this.maxTrailLength = 20;
            }

            getRandomColor() {
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#f7dc6f', '#bb8fce'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            update(hexagon) {
                // åº”ç”¨é‡åŠ›
                this.vy += params.gravity;

                // æ›´æ–°ä½ç½®
                this.x += this.vx;
                this.y += this.vy;

                // æ·»åŠ åˆ°è½¨è¿¹
                this.trail.push({ x: this.x, y: this.y, color: this.color });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }

                // æ£€æµ‹ä¸å…­è¾¹å½¢è¾¹ç•Œçš„ç¢°æ’
                if (!hexagon.containsPoint(this.x, this.y)) {
                    const { edge, normal, distance } = hexagon.getClosestEdge(this.x, this.y);

                    if (edge && normal) {
                        // å°†å°çƒæ¨å›å…­è¾¹å½¢å†…éƒ¨
                        this.x = edge.closestX + normal.x * (this.radius + 1);
                        this.y = edge.closestY + normal.y * (this.radius + 1);

                        // è®¡ç®—åå°„é€Ÿåº¦
                        const dotProduct = this.vx * normal.x + this.vy * normal.y;
                        this.vx -= 2 * dotProduct * normal.x;
                        this.vy -= 2 * dotProduct * normal.y;

                        // åº”ç”¨å¼¹æ€§
                        this.vx *= params.elasticity;
                        this.vy *= params.elasticity;

                        // æ”¹å˜é¢œè‰²
                        this.color = this.getRandomColor();

                        // å¢åŠ ç¢°æ’è®¡æ•°
                        stats.collisionCount++;
                    }
                }

                // è®¡ç®—å½“å‰é€Ÿåº¦
                stats.currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                stats.trailCount = this.trail.length;
            }

            draw() {
                // ç»˜åˆ¶è½¨è¿¹
                ctx.globalAlpha = 0.3;
                this.trail.forEach((point, index) => {
                    const alpha = (index / this.trail.length) * 0.5;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = point.color;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, this.radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                });

                // ç»˜åˆ¶å°çƒ
                ctx.globalAlpha = 1;

                // æ·»åŠ å‘å…‰æ•ˆæœ
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 15;

                // ç»˜åˆ¶å°çƒä¸»ä½“
                const gradient = ctx.createRadialGradient(
                    this.x - this.radius * 0.3,
                    this.y - this.radius * 0.3,
                    0,
                    this.x,
                    this.y,
                    this.radius
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.7, this.color);
                gradient.addColorStop(1, this.darkenColor(this.color));

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // é‡ç½®é˜´å½±
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }

            darkenColor(color) {
                // ç®€å•çš„é¢œè‰²å˜æš—å‡½æ•°
                const amount = 0.7;
                const num = parseInt(color.slice(1), 16);
                const r = Math.floor((num >> 16) * amount);
                const g = Math.floor(((num >> 8) & 0x00FF) * amount);
                const b = Math.floor((num & 0x0000FF) * amount);
                return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, '0')}`;
            }
        }

        // å…¨å±€å˜é‡
        let hexagon;
        let ball;
        let animationId;
        let lastTime = Date.now();
        let frameCount = 0;
        let lastFpsUpdate = Date.now();

        // åˆå§‹åŒ–æ¨¡æ‹Ÿ
        function initSimulation() {
            resizeCanvas();

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const hexRadius = Math.min(canvas.width, canvas.height) * 0.35;

            hexagon = new Hexagon(centerX, centerY, hexRadius);
            ball = new Ball(centerX, centerY, params.ballSize);

            stats.collisionCount = 0;
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = 'rgba(15, 15, 30, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // æ—‹è½¬å…­è¾¹å½¢
            hexagon.rotate(params.rotationSpeed * Math.PI / 180);

            // æ›´æ–°å’Œç»˜åˆ¶
            hexagon.draw();
            ball.update(hexagon);
            ball.draw();

            // æ›´æ–°FPS
            frameCount++;
            const now = Date.now();
            if (now - lastFpsUpdate >= 1000) {
                stats.fps = frameCount;
                frameCount = 0;
                lastFpsUpdate = now;
                updateInfoDisplay();
            }

            animationId = requestAnimationFrame(animate);
        }

        // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
        function updateInfoDisplay() {
            document.getElementById('collisionCount').textContent = stats.collisionCount;
            document.getElementById('currentSpeed').textContent = stats.currentSpeed.toFixed(1);
            document.getElementById('trailCount').textContent = stats.trailCount;
            document.getElementById('fps').textContent = stats.fps;
        }

        // æ›´æ–°å‚æ•°å€¼æ˜¾ç¤º
        function updateParameterDisplays() {
            document.getElementById('ballSizeValue').textContent = params.ballSize + 'px';
            document.getElementById('gravityValue').textContent = params.gravity.toFixed(2);
            document.getElementById('elasticityValue').textContent = params.elasticity.toFixed(2);
            document.getElementById('rotationSpeedValue').textContent = params.rotationSpeed.toFixed(1) + 'Â°/å¸§';
        }

        // é¢„è®¾é…ç½®
        function setPreset(preset) {
            switch(preset) {
                case 'lowGravity':
                    params.gravity = 0.1;
                    params.elasticity = 0.95;
                    params.rotationSpeed = 0.5;
                    break;
                case 'highBounce':
                    params.gravity = 0.8;
                    params.elasticity = 0.98;
                    params.rotationSpeed = 1;
                    break;
                case 'fastRotation':
                    params.gravity = 0.5;
                    params.elasticity = 0.9;
                    params.rotationSpeed = 4;
                    break;
                case 'chaos':
                    params.gravity = Math.random();
                    params.elasticity = Math.random();
                    params.rotationSpeed = Math.random() * 5;
                    params.ballSize = 5 + Math.random() * 25;
                    break;
            }

            // æ›´æ–°æ»‘å—å€¼
            document.getElementById('ballSize').value = params.ballSize;
            document.getElementById('gravity').value = params.gravity;
            document.getElementById('elasticity').value = params.elasticity;
            document.getElementById('rotationSpeed').value = params.rotationSpeed;

            // æ›´æ–°å°çƒå¤§å°
            if (ball) {
                ball.radius = params.ballSize;
            }

            updateParameterDisplays();
        }

        // é‡ç½®æ¨¡æ‹Ÿ
        function resetSimulation() {
            stats.collisionCount = 0;
            initSimulation();
        }

        // äº‹ä»¶ç›‘å¬å™¨
        document.getElementById('ballSize').addEventListener('input', (e) => {
            params.ballSize = parseInt(e.target.value);
            if (ball) {
                ball.radius = params.ballSize;
            }
            updateParameterDisplays();
        });

        document.getElementById('gravity').addEventListener('input', (e) => {
            params.gravity = parseFloat(e.target.value);
            updateParameterDisplays();
        });

        document.getElementById('elasticity').addEventListener('input', (e) => {
            params.elasticity = parseFloat(e.target.value);
            updateParameterDisplays();
        });

        document.getElementById('rotationSpeed').addEventListener('input', (e) => {
            params.rotationSpeed = parseFloat(e.target.value);
            updateParameterDisplays();
        });

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            resizeCanvas();
            initSimulation();
        });

        // å¯åŠ¨åº”ç”¨
        function start() {
            initSimulation();
            updateParameterDisplays();
            animate();
        }

        // é¡µé¢åŠ è½½å®Œæˆåå¯åŠ¨
        window.addEventListener('load', start);
    </script>
</body>
</html>