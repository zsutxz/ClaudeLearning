<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç –å—çƒŸå›±çˆ†ç ´æ¨¡æ‹Ÿå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            overflow: hidden;
            color: #fff;
            font-size: 14px;
        }

        #canvas {
            display: block;
            cursor: grab;
            background: linear-gradient(180deg, #87CEEB 0%, #98D8E8 50%, #B0E0E6 100%);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        #canvas:active {
            cursor: grabbing;
        }

        /* æ§åˆ¶é¢æ¿ */
        #control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            min-width: 280px;
        }

        #control-panel h3 {
            margin-bottom: 15px;
            color: #4CAF50;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            color: #ddd;
            font-size: 13px;
            font-weight: 500;
        }

        button {
            width: 100%;
            padding: 12px 16px;
            margin: 5px 0;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button:hover {
            background: linear-gradient(135deg, #45a049, #4CAF50);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(76, 175, 80, 0.3);
        }

        button:disabled {
            background: linear-gradient(135deg, #666, #555);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.6;
        }

        #explode-btn {
            background: linear-gradient(135deg, #f44336, #da190b);
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3);
        }

        #explode-btn:hover {
            background: linear-gradient(135deg, #da190b, #f44336);
            box-shadow: 0 6px 20px rgba(244, 67, 54, 0.4);
        }

        #reset-btn {
            background: linear-gradient(135deg, #2196F3, #1976D2);
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        }

        #reset-btn:hover {
            background: linear-gradient(135deg, #1976D2, #2196F3);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }

        /* ä¿¡æ¯æ˜¾ç¤º */
        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 13px;
            min-width: 200px;
        }

        .info-item {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-label {
            color: #aaa;
            font-weight: 500;
        }

        .info-value {
            color: #4CAF50;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        /* è§†è§’æ§åˆ¶æç¤º */
        .controls-hint {
            background: rgba(255, 255, 255, 0.1);
            padding: 12px;
            border-radius: 6px;
            margin-top: 15px;
            font-size: 12px;
            line-height: 1.6;
            border-left: 3px solid #4CAF50;
        }

        .controls-hint h4 {
            color: #4CAF50;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .controls-hint p {
            color: #ddd;
            margin: 4px 0;
        }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .status-waiting {
            background-color: #FFC107;
        }

        .status-simulating {
            background-color: #4CAF50;
        }

        .status-complete {
            background-color: #2196F3;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* åŠ è½½æç¤º */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            #control-panel {
                top: 10px;
                left: 10px;
                right: 10px;
                min-width: auto;
                padding: 15px;
            }

            #info-panel {
                bottom: 10px;
                left: 10px;
                right: 10px;
                min-width: auto;
            }

            .controls-hint {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <!-- åŠ è½½æç¤º -->
    <div id="loading">æ­£åœ¨åˆå§‹åŒ–æ¨¡æ‹Ÿå™¨...</div>

    <!-- ä¸»ç”»å¸ƒ -->
    <canvas id="canvas"></canvas>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div id="control-panel">
        <h3>ğŸ® æ§åˆ¶é¢æ¿</h3>

        <div class="control-group">
            <button id="explode-btn">ğŸ’£ å¼•çˆ†æ¨¡æ‹Ÿ</button>
            <button id="reset-btn">ğŸ”„ é‡ç½®åœºæ™¯</button>
        </div>

        <div class="controls-hint">
            <h4>ğŸ–±ï¸ 3Dè§†è§’æ§åˆ¶</h4>
            <p><strong>é¼ æ ‡å·¦é”®:</strong> æ—‹è½¬è§†è§’</p>
            <p><strong>é¼ æ ‡å³é”®:</strong> ç§»åŠ¨ä½ç½®</p>
            <p><strong>æ»šè½®:</strong> ç¼©æ”¾è§†å›¾</p>

            <h4 style="margin-top: 12px;">âŒ¨ï¸ å¿«æ·é”®</h4>
            <p><strong>ç©ºæ ¼/E:</strong> å¼•çˆ†</p>
            <p><strong>R:</strong> é‡ç½®</p>
            <p><strong>â†‘â†“:</strong> ç¼©æ”¾</p>
            <p><strong>WASD:</strong> ç§»åŠ¨ç›¸æœº</p>
        </div>
    </div>

    <!-- ä¿¡æ¯é¢æ¿ -->
    <div id="info-panel">
        <div class="info-item">
            <span class="info-label">ç‰©ç†å¯¹è±¡æ•°é‡:</span>
            <span class="info-value" id="object-count">0</span>
        </div>
        <div class="info-item">
            <span class="info-label">æ¨¡æ‹ŸçŠ¶æ€:</span>
            <span class="info-value">
                <span class="status-indicator status-waiting"></span>
                <span id="simulation-status">ç­‰å¾…å¼•çˆ†</span>
            </span>
        </div>
        <div class="info-item">
            <span class="info-label">å¸§ç‡ (FPS):</span>
            <span class="info-value" id="fps">60</span>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const loading = document.getElementById('loading');

        // UIå…ƒç´ 
        const explodeBtn = document.getElementById('explode-btn');
        const resetBtn = document.getElementById('reset-btn');
        const objectCountEl = document.getElementById('object-count');
        const simulationStatusEl = document.getElementById('simulation-status');
        const fpsEl = document.getElementById('fps');

        // ==================== 3Dæ•°å­¦åº“ ====================

        // 3Då‘é‡ç±»
        class Vector3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }

            // å‘é‡åŠ æ³•
            add(v) {
                return new Vector3(this.x + v.x, this.y + v.y, this.z + v.z);
            }

            // å‘é‡å‡æ³•
            subtract(v) {
                return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z);
            }

            // å‘é‡ä¹˜æ³•ï¼ˆæ ‡é‡ï¼‰
            multiply(scalar) {
                return new Vector3(this.x * scalar, this.y * scalar, this.z * scalar);
            }

            // å‘é‡ç‚¹ç§¯
            dot(v) {
                return this.x * v.x + this.y * v.y + this.z * v.z;
            }

            // å‘é‡å‰ç§¯
            cross(v) {
                return new Vector3(
                    this.y * v.z - this.z * v.y,
                    this.z * v.x - this.x * v.z,
                    this.x * v.y - this.y * v.x
                );
            }

            // å‘é‡é•¿åº¦
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }

            // å‘é‡å½’ä¸€åŒ–
            normalize() {
                const len = this.length();
                if (len === 0) return new Vector3();
                return new Vector3(this.x / len, this.y / len, this.z / len);
            }

            // å‘é‡å…‹éš†
            clone() {
                return new Vector3(this.x, this.y, this.z);
            }

            // æ—‹è½¬ï¼ˆç»•Yè½´ï¼‰
            rotateY(angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return new Vector3(
                    this.x * cos - this.z * sin,
                    this.y,
                    this.x * sin + this.z * cos
                );
            }

            // æ—‹è½¬ï¼ˆç»•Xè½´ï¼‰
            rotateX(angle) {
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                return new Vector3(
                    this.x,
                    this.y * cos - this.z * sin,
                    this.y * sin + this.z * cos
                );
            }
        }

        // 4x4çŸ©é˜µç±»
        class Matrix4 {
            constructor() {
                this.m = [
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ];
            }

            // é€è§†æŠ•å½±çŸ©é˜µ
            static perspective(fov, aspect, near, far) {
                const f = 1.0 / Math.tan(fov / 2);
                const rangeInv = 1 / (near - far);

                const matrix = new Matrix4();
                matrix.m = [
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (near + far) * rangeInv, -1,
                    0, 0, near * far * rangeInv * 2, 0
                ];
                return matrix;
            }

            // å¹³ç§»çŸ©é˜µ
            static translation(x, y, z) {
                const matrix = new Matrix4();
                matrix.m[12] = x;
                matrix.m[13] = y;
                matrix.m[14] = z;
                return matrix;
            }

            // ç¼©æ”¾çŸ©é˜µ
            static scale(x, y, z) {
                const matrix = new Matrix4();
                matrix.m[0] = x;
                matrix.m[5] = y;
                matrix.m[10] = z;
                return matrix;
            }

            // çŸ©é˜µä¹˜æ³•
            multiply(other) {
                const result = new Matrix4();
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        result.m[i * 4 + j] = 0;
                        for (let k = 0; k < 4; k++) {
                            result.m[i * 4 + j] += this.m[i * 4 + k] * other.m[k * 4 + j];
                        }
                    }
                }
                return result;
            }

            // å˜æ¢å‘é‡
            transformVector(v) {
                const w = this.m[3] * v.x + this.m[7] * v.y + this.m[11] * v.z + this.m[15];
                return new Vector3(
                    (this.m[0] * v.x + this.m[4] * v.y + this.m[8] * v.z + this.m[12]) / w,
                    (this.m[1] * v.x + this.m[5] * v.y + this.m[9] * v.z + this.m[13]) / w,
                    (this.m[2] * v.x + this.m[6] * v.y + this.m[10] * v.z + this.m[14]) / w
                );
            }
        }

        // ==================== 3Dæ¸²æŸ“å¼•æ“ ====================

        class Camera {
            constructor() {
                this.position = new Vector3(0, -200, 300);
                this.rotation = new Vector3(-0.3, 0, 0);
                this.fov = Math.PI / 4;
                this.near = 0.1;
                this.far = 1000;
            }

            // è·å–è§†å›¾çŸ©é˜µ
            getViewMatrix(aspect) {
                let matrix = Matrix4.perspective(this.fov, aspect, this.near, this.far);

                // åº”ç”¨ç›¸æœºæ—‹è½¬
                matrix = matrix.multiply(Matrix4.translation(0, 0, -this.position.z));
                matrix = matrix.multiply(Matrix4.translation(0, 0, 0));

                return matrix;
            }

            // æŠ•å½±3Dç‚¹åˆ°2Då±å¹•
            project(point3d, aspect) {
                const viewMatrix = this.getViewMatrix(aspect);
                const transformed = viewMatrix.transformVector(point3d);

                return {
                    x: transformed.x * canvas.width / 2 + canvas.width / 2,
                    y: -transformed.y * canvas.height / 2 + canvas.height / 2,
                    z: transformed.z
                };
            }
        }

        // ç –å—ç±»
        class Brick {
            constructor(x, y, z, width = 20, height = 10, depth = 15) {
                this.position = new Vector3(x, y, z);
                this.velocity = new Vector3();
                this.rotation = new Vector3();
                this.angularVelocity = new Vector3();
                this.width = width;
                this.height = height;
                this.depth = depth;
                this.color = this.generateBrickColor();
                this.isStatic = true;
                this.vertices = this.generateVertices();
            }

            generateBrickColor() {
                const colors = [
                    '#8B4513', '#A0522D', '#CD853F', '#DEB887',
                    '#D2691E', '#BC8F8F', '#F4A460', '#DAA520'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            generateVertices() {
                const { x, y, z } = this.position;
                const w2 = this.width / 2;
                const h2 = this.height / 2;
                const d2 = this.depth / 2;

                return [
                    new Vector3(x - w2, y - h2, z - d2),
                    new Vector3(x + w2, y - h2, z - d2),
                    new Vector3(x + w2, y + h2, z - d2),
                    new Vector3(x - w2, y + h2, z - d2),
                    new Vector3(x - w2, y - h2, z + d2),
                    new Vector3(x + w2, y - h2, z + d2),
                    new Vector3(x + w2, y + h2, z + d2),
                    new Vector3(x - w2, y + h2, z + d2)
                ];
            }

            update(deltaTime) {
                if (!this.isStatic) {
                    // æ›´æ–°ä½ç½®
                    this.position = this.position.add(this.velocity.multiply(deltaTime));

                    // æ›´æ–°æ—‹è½¬
                    this.rotation = this.rotation.add(this.angularVelocity.multiply(deltaTime));

                    // é‡åŠ›
                    this.velocity.y += 500 * deltaTime;

                    // ç©ºæ°”é˜»åŠ›
                    this.velocity = this.velocity.multiply(0.995);
                    this.angularVelocity = this.angularVelocity.multiply(0.98);

                    // æ›´æ–°é¡¶ç‚¹
                    this.vertices = this.generateVertices();
                }
            }

            // AABBè¾¹ç•Œæ¡†ç¢°æ’æ£€æµ‹
            getBounds() {
                const w2 = this.width / 2;
                const h2 = this.height / 2;
                const d2 = this.depth / 2;

                return {
                    min: new Vector3(
                        this.position.x - w2,
                        this.position.y - h2,
                        this.position.z - d2
                    ),
                    max: new Vector3(
                        this.position.x + w2,
                        this.position.y + h2,
                        this.position.z + d2
                    )
                };
            }

            // ç –å—é—´ç¢°æ’æ£€æµ‹
            checkCollision(other) {
                if (this.isStatic && other.isStatic) return false;

                const bounds1 = this.getBounds();
                const bounds2 = other.getBounds();

                return !(bounds1.max.x < bounds2.min.x || bounds2.max.x < bounds1.min.x ||
                        bounds1.max.y < bounds2.min.y || bounds2.max.y < bounds1.min.y ||
                        bounds1.max.z < bounds2.min.z || bounds2.max.z < bounds1.min.z);
            }

            // å¤„ç†ç¢°æ’å“åº”
            resolveCollision(other) {
                if (this.isStatic && other.isStatic) return;

                const bounds1 = this.getBounds();
                const bounds2 = other.getBounds();

                // è®¡ç®—é‡å æ·±åº¦
                const overlapX = Math.min(bounds1.max.x - bounds2.min.x, bounds2.max.x - bounds1.min.x);
                const overlapY = Math.min(bounds1.max.y - bounds2.min.y, bounds2.max.y - bounds1.min.y);
                const overlapZ = Math.min(bounds1.max.z - bounds2.min.z, bounds2.max.z - bounds1.min.z);

                // æ‰¾åˆ°æœ€å°é‡å è½´
                let minOverlap = overlapX;
                let normal = new Vector3(1, 0, 0);

                if (overlapY < minOverlap) {
                    minOverlap = overlapY;
                    normal = new Vector3(0, 1, 0);
                }
                if (overlapZ < minOverlap) {
                    minOverlap = overlapZ;
                    normal = new Vector3(0, 0, 1);
                }

                // åˆ†ç¦»ç –å—
                const separation = normal.multiply(minOverlap * 0.5);
                if (!this.isStatic) {
                    this.position = this.position.subtract(separation);
                }
                if (!other.isStatic) {
                    other.position = other.position.add(separation);
                }

                // äº¤æ¢é€Ÿåº¦åˆ†é‡
                if (!this.isStatic && !other.isStatic) {
                    const relativeVelocity = this.velocity.subtract(other.velocity);
                    const velocityAlongNormal = relativeVelocity.dot(normal);

                    if (velocityAlongNormal > 0) return;

                    const restitution = 0.6;
                    const impulse = 2 * velocityAlongNormal / 2;
                    const impulseVector = normal.multiply(impulse * restitution);

                    this.velocity = this.velocity.subtract(impulseVector);
                    other.velocity = other.velocity.add(impulseVector);
                }
            }

            render(ctx, camera) {
                const aspect = canvas.width / canvas.height;

                // è½¬æ¢æ‰€æœ‰é¡¶ç‚¹åˆ°å±å¹•åæ ‡
                const screenVertices = this.vertices.map(vertex => {
                    return camera.project(vertex, aspect);
                });

                // å®šä¹‰é¢çš„é¡¶ç‚¹ç´¢å¼•
                const faces = [
                    [0, 1, 2, 3], // å‰é¢
                    [4, 5, 6, 7], // åé¢
                    [0, 4, 7, 3], // å·¦é¢
                    [1, 5, 6, 2], // å³é¢
                    [0, 1, 5, 4], // åº•é¢
                    [3, 2, 6, 7]  // é¡¶é¢
                ];

                // è®¡ç®—æ¯ä¸ªé¢çš„æ·±åº¦å¹¶æ’åº
                const facesWithDepth = faces.map((face, index) => {
                    const centerZ = face.reduce((sum, vertexIndex) =>
                        sum + screenVertices[vertexIndex].z, 0) / face.length;
                    return { face, index, depth: centerZ };
                });

                facesWithDepth.sort((a, b) => a.depth - b.depth);

                // ç»˜åˆ¶æ’åºåçš„é¢
                facesWithDepth.forEach(({ face, index }) => {
                    ctx.beginPath();
                    ctx.moveTo(screenVertices[face[0]].x, screenVertices[face[0]].y);

                    for (let i = 1; i < face.length; i++) {
                        ctx.lineTo(screenVertices[face[i]].x, screenVertices[face[i]].y);
                    }

                    ctx.closePath();

                    // è®¡ç®—å…‰ç…§
                    const brightness = 0.7 + index * 0.05;
                    const rgb = this.hexToRgb(this.color);
                    ctx.fillStyle = `rgba(${rgb.r * brightness}, ${rgb.g * brightness}, ${rgb.b * brightness}, 1)`;
                    ctx.fill();

                    ctx.strokeStyle = `rgba(0, 0, 0, 0.3)`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 139, g: 69, b: 19 };
            }

            explode(force = 500) {
                this.isStatic = false;
                const randomDirection = new Vector3(
                    (Math.random() - 0.5) * 2,
                    Math.random() * 0.5,
                    (Math.random() - 0.5) * 2
                ).normalize();

                this.velocity = randomDirection.multiply(force);
                this.angularVelocity = new Vector3(
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5
                );
            }
        }

        // æ¸²æŸ“å™¨ç±»
        class Renderer {
            constructor() {
                this.camera = new Camera();
                this.bricks = [];
                this.isExploding = false;
                this.lastTime = 0;
                this.fps = 60;
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                this.explosionParticles = [];
                this.explosionLight = 0;
            }

            addBrick(brick) {
                this.bricks.push(brick);
            }

            clearBricks() {
                this.bricks = [];
            }

            explode() {
                if (!this.isExploding) {
                    this.isExploding = true;
                    this.explosionLight = 1.0;
                    this.createExplosionEffect();

                    this.bricks.forEach(brick => {
                        brick.explode();
                    });
                    updateSimulationStatus('æ¨¡æ‹Ÿä¸­', 'simulating');
                }
            }

            createExplosionEffect() {
                // åˆ›å»ºçˆ†ç‚¸ç²’å­æ•ˆæœ
                for (let i = 0; i < 50; i++) {
                    this.explosionParticles.push({
                        position: new Vector3(0, -50, 0),
                        velocity: new Vector3(
                            (Math.random() - 0.5) * 800,
                            Math.random() * 400,
                            (Math.random() - 0.5) * 800
                        ),
                        life: 1.0,
                        color: `hsl(${Math.random() * 60}, 100%, ${50 + Math.random() * 50}%)`
                    });
                }
            }

            reset() {
                this.clearBricks();
                this.isExploding = false;
                this.explosionParticles = [];
                this.explosionLight = 0;
                this.buildChimney();
                updateSimulationStatus('ç­‰å¾…å¼•çˆ†', 'waiting');
            }

            buildChimney() {
                const layers = 15;
                const bricksPerLayer = 8;
                const radius = 60;
                const brickWidth = 15;
                const brickHeight = 8;
                const brickDepth = 12;

                for (let layer = 0; layer < layers; layer++) {
                    const y = -layer * brickHeight;
                    const angleOffset = layer % 2 === 0 ? 0 : Math.PI / bricksPerLayer;

                    for (let i = 0; i < bricksPerLayer; i++) {
                        const angle = (i * 2 * Math.PI / bricksPerLayer) + angleOffset;
                        const x = Math.cos(angle) * radius;
                        const z = Math.sin(angle) * radius;

                        const brick = new Brick(x, y, z, brickWidth, brickHeight, brickDepth);
                        this.addBrick(brick);
                    }
                }

                updateObjectCount(this.bricks.length);
            }

            update(currentTime) {
                const deltaTime = Math.min((currentTime - this.lastTime) / 1000, 0.1);
                this.lastTime = currentTime;

                // æ›´æ–°FPS
                this.frameCount++;
                if (currentTime - this.lastFpsUpdate > 1000) {
                    this.fps = Math.round(this.frameCount * 1000 / (currentTime - this.lastFpsUpdate));
                    fpsEl.textContent = this.fps;
                    this.frameCount = 0;
                    this.lastFpsUpdate = currentTime;
                }

                // æ›´æ–°çˆ†ç‚¸å…‰ç…§æ•ˆæœ
                if (this.explosionLight > 0) {
                    this.explosionLight -= deltaTime * 2;
                    this.explosionLight = Math.max(0, this.explosionLight);
                }

                // æ›´æ–°çˆ†ç‚¸ç²’å­
                this.explosionParticles = this.explosionParticles.filter(particle => {
                    particle.position = particle.position.add(particle.velocity.multiply(deltaTime));
                    particle.velocity.y += 800 * deltaTime; // é‡åŠ›
                    particle.life -= deltaTime * 1.5;
                    return particle.life > 0;
                });

                // æ›´æ–°æ‰€æœ‰ç –å—
                let hasMovingBricks = false;
                const movingBricks = [];

                this.bricks.forEach(brick => {
                    brick.update(deltaTime);
                    if (!brick.isStatic) {
                        hasMovingBricks = true;
                        movingBricks.push(brick);

                        // åœ°é¢ç¢°æ’æ£€æµ‹
                        if (brick.position.y > 150) {
                            brick.position.y = 150;
                            brick.velocity.y *= -0.3;
                            brick.velocity.x *= 0.8;
                            brick.velocity.z *= 0.8;

                            // å¦‚æœé€Ÿåº¦å¾ˆå°ï¼Œåœæ­¢è¿åŠ¨
                            if (Math.abs(brick.velocity.y) < 10 &&
                                Math.abs(brick.velocity.x) < 5 &&
                                Math.abs(brick.velocity.z) < 5) {
                                brick.velocity = new Vector3();
                                brick.isStatic = true;
                            }
                        }

                        // è¾¹ç•Œé™åˆ¶
                        const maxDistance = 500;
                        if (Math.abs(brick.position.x) > maxDistance) {
                            brick.position.x = Math.sign(brick.position.x) * maxDistance;
                            brick.velocity.x *= -0.5;
                        }
                        if (Math.abs(brick.position.z) > maxDistance) {
                            brick.position.z = Math.sign(brick.position.z) * maxDistance;
                            brick.velocity.z *= -0.5;
                        }
                    }
                });

                // ç –å—é—´ç¢°æ’æ£€æµ‹ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼šåªæ£€æµ‹ç§»åŠ¨ä¸­çš„ç –å—ï¼‰
                for (let i = 0; i < movingBricks.length; i++) {
                    for (let j = i + 1; j < movingBricks.length; j++) {
                        if (movingBricks[i].checkCollision(movingBricks[j])) {
                            movingBricks[i].resolveCollision(movingBricks[j]);
                        }
                    }
                }

                // æ£€æŸ¥æ¨¡æ‹Ÿæ˜¯å¦å®Œæˆ
                if (this.isExploding && !hasMovingBricks && this.explosionParticles.length === 0) {
                    this.isExploding = false;
                    updateSimulationStatus('æ¨¡æ‹Ÿå®Œæˆ', 'complete');
                }

                updateObjectCount(this.bricks.length);
            }

            render() {
                // æ¸…ç©ºç”»å¸ƒ
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // åº”ç”¨çˆ†ç‚¸å…‰ç…§æ•ˆæœ
                if (this.explosionLight > 0) {
                    ctx.fillStyle = `rgba(255, 200, 100, ${this.explosionLight * 0.3})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                // ç»˜åˆ¶åœ°é¢
                this.renderGround();

                // ç»˜åˆ¶æ‰€æœ‰ç –å—
                this.bricks.forEach(brick => {
                    brick.render(ctx, this.camera);
                });

                // ç»˜åˆ¶çˆ†ç‚¸ç²’å­
                this.renderExplosionParticles();
            }

            renderExplosionParticles() {
                const aspect = canvas.width / canvas.height;

                this.explosionParticles.forEach(particle => {
                    const screenPos = this.camera.project(particle.position, aspect);
                    const size = 3 + (1 - particle.life) * 5;

                    ctx.save();
                    ctx.globalAlpha = particle.life;
                    ctx.fillStyle = particle.color;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = particle.color;

                    ctx.beginPath();
                    ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.restore();
                });
            }

            renderGround() {
                const aspect = canvas.width / canvas.height;
                const groundSize = 500;
                const groundY = 160;

                // åˆ›å»ºåœ°é¢ç½‘æ ¼ç‚¹
                const groundColor = '#3a5f3a';
                ctx.strokeStyle = groundColor;
                ctx.lineWidth = 1;

                // ç»˜åˆ¶ç½‘æ ¼çº¿
                for (let i = -groundSize; i <= groundSize; i += 50) {
                    // æ¨ªçº¿
                    const start1 = this.camera.project(new Vector3(-groundSize, groundY, i), aspect);
                    const end1 = this.camera.project(new Vector3(groundSize, groundY, i), aspect);

                    ctx.beginPath();
                    ctx.moveTo(start1.x, start1.y);
                    ctx.lineTo(end1.x, end1.y);
                    ctx.stroke();

                    // ç«–çº¿
                    const start2 = this.camera.project(new Vector3(i, groundY, -groundSize), aspect);
                    const end2 = this.camera.project(new Vector3(i, groundY, groundSize), aspect);

                    ctx.beginPath();
                    ctx.moveTo(start2.x, start2.y);
                    ctx.lineTo(end2.x, end2.y);
                    ctx.stroke();
                }

                // ç»˜åˆ¶åœ°é¢
                const corners = [
                    this.camera.project(new Vector3(-groundSize, groundY, -groundSize), aspect),
                    this.camera.project(new Vector3(groundSize, groundY, -groundSize), aspect),
                    this.camera.project(new Vector3(groundSize, groundY, groundSize), aspect),
                    this.camera.project(new Vector3(-groundSize, groundY, groundSize), aspect)
                ];

                ctx.fillStyle = 'rgba(58, 95, 58, 0.3)';
                ctx.beginPath();
                ctx.moveTo(corners[0].x, corners[0].y);
                corners.forEach(corner => ctx.lineTo(corner.x, corner.y));
                ctx.closePath();
                ctx.fill();
            }
        }

        // ==================== åº”ç”¨ç¨‹åº ====================

        let renderer;

        // UIæ›´æ–°å‡½æ•°
        function updateObjectCount(count) {
            objectCountEl.textContent = count;
        }

        function updateSimulationStatus(status, type) {
            simulationStatusEl.textContent = status;
            const indicator = document.querySelector('.status-indicator');
            indicator.className = 'status-indicator';
            switch (type) {
                case 'waiting':
                    indicator.classList.add('status-waiting');
                    break;
                case 'simulating':
                    indicator.classList.add('status-simulating');
                    break;
                case 'complete':
                    indicator.classList.add('status-complete');
                    break;
            }
        }

        // ç”»å¸ƒè®¾ç½®
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // ä¸»åŠ¨ç”»å¾ªç¯
        function animate(currentTime) {
            renderer.update(currentTime);
            renderer.render();
            requestAnimationFrame(animate);
        }

        // äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            // æŒ‰é’®äº‹ä»¶
            explodeBtn.addEventListener('click', () => {
                renderer.explode();
            });

            resetBtn.addEventListener('click', () => {
                renderer.reset();
            });

            // é”®ç›˜å¿«æ·é”®
            document.addEventListener('keydown', (e) => {
                switch (e.key.toLowerCase()) {
                    case ' ':
                    case 'e':
                        e.preventDefault();
                        renderer.explode();
                        break;
                    case 'r':
                        e.preventDefault();
                        renderer.reset();
                        break;
                    case 'arrowup':
                        renderer.camera.position.z -= 10;
                        renderer.camera.position.z = Math.max(100, renderer.camera.position.z);
                        break;
                    case 'arrowdown':
                        renderer.camera.position.z += 10;
                        renderer.camera.position.z = Math.min(800, renderer.camera.position.z);
                        break;
                    case 'w':
                        renderer.camera.position.y += 10;
                        break;
                    case 's':
                        renderer.camera.position.y -= 10;
                        break;
                    case 'a':
                        renderer.camera.position.x -= 10;
                        break;
                    case 'd':
                        renderer.camera.position.x += 10;
                        break;
                }
            });

            // çª—å£è°ƒæ•´
            window.addEventListener('resize', resizeCanvas);

            // é¼ æ ‡æ§åˆ¶ï¼ˆæ”¹è¿›ç‰ˆï¼‰
            let isDragging = false;
            let lastMouseX = 0;
            let lastMouseY = 0;
            let mouseButton = 0;

            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                mouseButton = e.button;
                canvas.style.cursor = 'grabbing';
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;

                    if (mouseButton === 0) { // å·¦é”® - æ—‹è½¬
                        renderer.camera.rotation.y += deltaX * 0.01;
                        renderer.camera.rotation.x += deltaY * 0.01;
                        renderer.camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, renderer.camera.rotation.x));
                    } else if (mouseButton === 2) { // å³é”® - å¹³ç§»
                        const moveSpeed = 0.5;
                        renderer.camera.position.x -= deltaX * moveSpeed;
                        renderer.camera.position.y += deltaY * moveSpeed;
                    }

                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });

            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });

            // é˜»æ­¢å³é”®èœå•
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // æ»šè½®ç¼©æ”¾
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                renderer.camera.position.z += e.deltaY * zoomSpeed;
                renderer.camera.position.z = Math.max(100, Math.min(800, renderer.camera.position.z));
            });

            // è§¦æ‘¸æ”¯æŒï¼ˆç§»åŠ¨è®¾å¤‡ï¼‰
            let touchStartX = 0;
            let touchStartY = 0;

            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            });

            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1) {
                    e.preventDefault();
                    const deltaX = e.touches[0].clientX - touchStartX;
                    const deltaY = e.touches[0].clientY - touchStartY;

                    renderer.camera.rotation.y += deltaX * 0.01;
                    renderer.camera.rotation.x += deltaY * 0.01;
                    renderer.camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, renderer.camera.rotation.x));

                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
            });
        }

        // åˆå§‹åŒ–
        function init() {
            resizeCanvas();

            renderer = new Renderer();
            renderer.buildChimney();

            setupEventListeners();

            // éšè—åŠ è½½æç¤º
            setTimeout(() => {
                loading.style.display = 'none';
            }, 1000);

            // å¯åŠ¨åŠ¨ç”»å¾ªç¯
            requestAnimationFrame(animate);

            console.log('ç –å—çƒŸå›±çˆ†ç ´æ¨¡æ‹Ÿå™¨å·²åˆå§‹åŒ–');
        }

        // å¯åŠ¨åº”ç”¨
        init();
    </script>
</body>
</html>