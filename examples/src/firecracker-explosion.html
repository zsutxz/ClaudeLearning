<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firecracker Box Explosion Chain Reaction</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 18px;
            text-shadow: 0 0 5px #000;
            z-index: 100;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
        }
        button {
            background: #ff5722;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 87, 34, 0.5);
            transition: all 0.3s;
        }
        button:hover {
            background: #ff7043;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 87, 34, 0.8);
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info">Firecracker Box Explosion Chain Reaction</div>
        <div id="loading">Loading Three.js...</div>
        <div id="controls">
            <button id="explodeBtn">Ignite Firecrackers</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Main variables
        let scene, camera, renderer;
        let firecrackers = [];
        let sparks = [];
        let particles = [];
        let box;
        let clock = new THREE.Clock();
        let explodeTime = 0;
        let exploded = false;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        
        // Initialize the scene
        function init() {
            // Remove loading text
            document.getElementById('loading').style.display = 'none';
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000022);
            scene.fog = new THREE.Fog(0x000022, 20, 100);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 15);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0xff5722, 2, 50);
            pointLight.position.set(0, 5, 0);
            pointLight.castShadow = true;
            scene.add(pointLight);
            
            // Create firecracker box
            createBox();
            
            // Create firecrackers inside the box
            createFirecrackers();
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('explodeBtn').addEventListener('click', igniteFirecrackers);
            document.addEventListener('click', onMouseClick);
            
            // Start animation
            animate();
        }
        
        // Create the firecracker box
        function createBox() {
            // Box dimensions
            const width = 8, height = 5, depth = 5;
            
            // Create box geometry and material
            const geometry = new THREE.BoxGeometry(width, height, depth);
            
            // Create wireframe for the box
            const wireframe = new THREE.WireframeGeometry(geometry);
            const line = new THREE.LineSegments(wireframe);
            line.material.depthTest = false;
            line.material.opacity = 0.25;
            line.material.transparent = true;
            line.material.color.set(0x444444);
            
            // Create box group
            box = new THREE.Group();
            
            // Create sides of the box (semi-transparent)
            const sides = [
                { pos: [0, 0, depth/2], rot: [0, 0, 0] }, // front
                { pos: [0, 0, -depth/2], rot: [0, Math.PI, 0] }, // back
                { pos: [-width/2, 0, 0], rot: [0, Math.PI/2, 0] }, // left
                { pos: [width/2, 0, 0], rot: [0, -Math.PI/2, 0] }, // right
                { pos: [0, height/2, 0], rot: [-Math.PI/2, 0, 0] }, // top
                { pos: [0, -height/2, 0], rot: [Math.PI/2, 0, 0] }  // bottom
            ];
            
            sides.forEach(side => {
                const planeGeometry = new THREE.PlaneGeometry(width, height);
                const planeMaterial = new THREE.MeshPhongMaterial({
                    color: 0xdddddd,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.DoubleSide
                });
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.position.set(...side.pos);
                plane.rotation.set(...side.rot);
                plane.receiveShadow = true;
                box.add(plane);
            });
            
            box.add(line);
            scene.add(box);
        }
        
        // Create firecrackers inside the box
        function createFirecrackers() {
            const boxWidth = 7, boxHeight = 4, boxDepth = 4;
            const spacing = 1.2;
            const rows = 3;
            const cols = 3;
            const layers = 2;
            
            for (let layer = 0; layer < layers; layer++) {
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        const x = (col - (cols-1)/2) * spacing;
                        const y = (layer - (layers-1)/2) * spacing;
                        const z = (row - (rows-1)/2) * spacing;
                        
                        createFirecracker(x, y, z);
                    }
                }
            }
        }
        
        // Create a single firecracker
        function createFirecracker(x, y, z) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            
            // Firecracker body
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.8, 8);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff0000,
                shininess: 30
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.x = Math.PI / 2;
            body.castShadow = true;
            group.add(body);
            
            // Firecracker top
            const topGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const topMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffff00,
                emissive: 0x222200
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 0.4;
            top.castShadow = true;
            group.add(top);
            
            // Wick
            const wickGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 4);
            const wickMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const wick = new THREE.Mesh(wickGeometry, wickMaterial);
            wick.position.y = 0.6;
            wick.rotation.x = Math.PI / 2;
            group.add(wick);
            
            // Add to scene and store reference
            scene.add(group);
            firecrackers.push({
                group: group,
                exploded: false,
                explodeTime: 0,
                delay: Math.random() * 2 // Random delay for chain reaction
            });
        }
        
        // Ignite all firecrackers
        function igniteFirecrackers() {
            if (!exploded) {
                exploded = true;
                explodeTime = 0;
                
                // Light the first firecracker immediately
                if (firecrackers.length > 0) {
                    explodeFirecracker(firecrackers[0]);
                }
            }
        }
        
        // Explode a single firecracker
        function explodeFirecracker(firecracker) {
            if (firecracker.exploded) return;
            
            firecracker.exploded = true;
            firecracker.explodeTime = 0;
            
            // Remove firecracker from scene
            scene.remove(firecracker.group);
            
            // Create explosion effect
            createExplosion(firecracker.group.position.x, firecracker.group.position.y, firecracker.group.position.z);
            
            // Find nearby firecrackers to trigger chain reaction
            setTimeout(() => {
                firecrackers.forEach(other => {
                    if (!other.exploded && other !== firecracker) {
                        const distance = firecracker.group.position.distanceTo(other.group.position);
                        if (distance < 3) {
                            // Random chance to trigger based on distance
                            const probability = Math.max(0, 1 - distance / 3);
                            if (Math.random() < probability) {
                                explodeFirecracker(other);
                            }
                        }
                    }
                });
            }, 100 + Math.random() * 200);
        }
        
        // Create explosion effect
        function createExplosion(x, y, z) {
            // Create sparks
            const sparkCount = 50;
            for (let i = 0; i < sparkCount; i++) {
                const sparkGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                const sparkMaterial = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color(Math.random() * 0xffffff),
                    emissive: 0xffffff
                });
                const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                spark.position.set(x, y, z);
                
                // Random velocity
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                
                sparks.push({
                    mesh: spark,
                    velocity: velocity,
                    life: 1.0,
                    decay: 0.02
                });
                
                scene.add(spark);
            }
            
            // Create particle explosion
            const particleCount = 100;
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                const colors = [0xff5722, 0xff9800, 0xffeb3b, 0xf44336, 0x9c27b0];
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(x, y, z);
                
                // Random velocity with spherical distribution
                const speed = 5 + Math.random() * 10;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const vx = speed * Math.sin(phi) * Math.cos(theta);
                const vy = speed * Math.sin(phi) * Math.sin(theta);
                const vz = speed * Math.cos(phi);
                
                particles.push({
                    mesh: particle,
                    velocity: new THREE.Vector3(vx, vy, vz),
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.02,
                    gravity: 0.1
                });
                
                scene.add(particle);
            }
        }
        
        // Update explosions
        function updateExplosions(delta) {
            // Update sparks
            for (let i = sparks.length - 1; i >= 0; i--) {
                const spark = sparks[i];
                spark.life -= spark.decay;
                
                if (spark.life <= 0) {
                    scene.remove(spark.mesh);
                    sparks.splice(i, 1);
                } else {
                    spark.mesh.position.add(spark.velocity.clone().multiplyScalar(delta * 5));
                    spark.mesh.material.opacity = spark.life;
                }
            }
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.life -= particle.decay;
                
                if (particle.life <= 0) {
                    scene.remove(particle.mesh);
                    particles.splice(i, 1);
                } else {
                    particle.velocity.y -= particle.gravity * delta * 60;
                    particle.mesh.position.add(particle.velocity.clone().multiplyScalar(delta));
                    particle.mesh.material.opacity = particle.life;
                }
            }
        }
        
        // Handle mouse click for interaction
        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersections with firecrackers
            const intersects = raycaster.intersectObjects(
                firecrackers.map(f => f.group).filter(g => g.parent !== null)
            );
            
            if (intersects.length > 0) {
                // Find the clicked firecracker
                const clickedGroup = intersects[0].object.parent;
                const clickedFirecracker = firecrackers.find(f => f.group === clickedGroup);
                
                if (clickedFirecracker && !clickedFirecracker.exploded) {
                    explodeFirecracker(clickedFirecracker);
                }
            }
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // Rotate camera around the scene
            if (!exploded) {
                camera.position.x = Math.sin(time * 0.2) * 15;
                camera.position.z = Math.cos(time * 0.2) * 15;
                camera.lookAt(0, 0, 0);
            }
            
            // Update explosions
            updateExplosions(delta);
            
            // Update firecrackers (wiggle effect before explosion)
            if (!exploded) {
                firecrackers.forEach((firecracker, index) => {
                    if (!firecracker.exploded) {
                        const group = firecracker.group;
                        group.rotation.x = Math.sin(time * 5 + index) * 0.1;
                        group.rotation.z = Math.cos(time * 4 + index) * 0.1;
                        
                        // Slight floating effect
                        group.position.y = Math.sin(time * 2 + index) * 0.1;
                    }
                });
            }
            
            renderer.render(scene, camera);
        }
        
        // Start everything
        window.onload = init;
    </script>
</body>
</html>